# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Solution path of ridge regression by gradient descent method
#' 
#' @description
#' Generate solution of ridge regression by using gradient descent method at each grid point.
#' Grid points are adaptively selected to save computation while maintaining the high accuracy of solution path.
#' 
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param alpha_init Initial step size specified to start the iteration
#' 
#' @details
#' This function will be called by the main function l2path, with class = "square" and method = "GD".
#' 
#' @return theta: Generated solution path
#' @return alpha_t_vec: Adaptively chosen step size
#' @return t_vec: Adaptively selected grid points
#' @return n_vec: Number of gradient steps at each grid point
regression_GD_path <- function(X, Y, t_max, alpha_init) {
    .Call(`_l2path_regression_GD_path`, X, Y, t_max, alpha_init)
}

#' Solution path of ridge regression by Newton method (\eqn{n \geq p})
#' 
#' @description
#' Generate solution of ridge regression by using one-step Newton method at each grid point.
#' Grid points are adaptively selected to save computation while maintaining the high accuracy of solution path.
#' 
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param alpha_init Initial step size specified to start the iteration
#' 
#' @details
#' This function will be called by the main function l2path, with class = "square" and method = "Newton_low".
#' 
#' @return theta Generated solution path
#' @return alpha_t_vec Adaptively chosen step size
#' @return t_vec Adaptively selected grid points
regression_Newton_path_low_dimension_vary <- function(X, Y, t_max, alpha_init) {
    .Call(`_l2path_regression_Newton_path_low_dimension_vary`, X, Y, t_max, alpha_init)
}

#' Solution path of ridge regression by Newton method (\eqn{n < p})
#' 
#' @description
#' Generate solution of ridge regression by using one-step Newton method at each grid point. 
#' Woodbury matrix identity is applied to compute the matrix inverse.
#' Grid points are adaptively selected to save computation while maintaining the high accuracy of solution path.
#' 
#' 
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} response vector
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param alpha_init Initial step size specified to start the iteration
#' 
#' @details
#' This function will be called by the main function l2path, with class = "square" and method = "Newton_high".
#' 
#' @return theta Generated solution path
#' @return alpha_t_vec Adaptively chosen step size
#' @return t_vec Adaptively selected grid points
regression_Newton_path_high_dimension_vary <- function(X, Y, t_max, alpha_init) {
    .Call(`_l2path_regression_Newton_path_high_dimension_vary`, X, Y, t_max, alpha_init)
}

#' Solution path of \eqn{\ell_2} regularized logistic regression by gradient descent
#' 
#' @description
#' Generate solution of \eqn{\ell_2} regularized logistic regression by using gradient descent method at each grid point.
#' Grid points are adaptively selected to save computation while maintaining the high accuracy of solution path.
#' 
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} binary vector
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param alpha_init Initial step size specified to start the iteration
#' 
#' 
#' @details
#' This function will be called by the main function l2path, with class = "logistic" and method = "GD".
#' 
#' @return theta Generated solution path
#' @return alpha_t_vec Adaptively chosen step size
#' @return t_vec Adaptively selected grid points
#' @return n_vec Number of gradient steps at each grid point
logistic_GD_path <- function(X, Y, t_max, alpha_init) {
    .Call(`_l2path_logistic_GD_path`, X, Y, t_max, alpha_init)
}

#' Solution path of \eqn{\ell_2} regularized logistic regression by Newton method (\eqn{n \geq p})
#' 
#' @description
#' Generate solution of \eqn{\ell_2} regularized logistic regression by using one-step Newton method at each grid point. 
#' Grid points are adaptively selected to save computation while maintaining the high accuracy of solution path.
#' 
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} binary vector
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param alpha_init Initial step size specified to start the iteration
#' 
#' @details
#' This function will be called by the main function l2path, with class = "logistic" and method = "Newton_low".
#' 
#' @return theta Generated solution path
#' @return alpha_t_vec Adaptively chosen step size
#' @return t_vec Adaptively selected grid points
logistic_Newton_path_low_dimension_vary <- function(X, Y, t_max, alpha_init) {
    .Call(`_l2path_logistic_Newton_path_low_dimension_vary`, X, Y, t_max, alpha_init)
}

#' Solution path of \eqn{\ell_2} regularized logistic regression by Newton method (\eqn{n < p})
#' 
#' @description
#' Generate solution of \eqn{\ell_2} regularized logistic regression by using one-step Newton method at each grid point. 
#' Woodbury matrix identity is applied to compute the matrix inverse.
#' Grid points are adaptively selected to save computation while maintaining the high accuracy of solution path.
#' 
#' 
#' @param X A \eqn{n \times p} feature matrix
#' @param Y A \eqn{n \times 1} binary vector
#' @param t_max Range of solution path \eqn{[0, t_{\max}]}
#' @param alpha_init Initial step size specified to start the iteration
#' 
#' @details
#' This function will be called by the main function l2path, with class = "logistic" and method = "Newton_high".
#' 
#' @return theta Generated solution path
#' @return alpha_t_vec Adaptively chosen step size
#' @return t_vec Adaptively selected grid points
logistic_Newton_path_high_dimension_vary <- function(X, Y, t_max, alpha_init) {
    .Call(`_l2path_logistic_Newton_path_high_dimension_vary`, X, Y, t_max, alpha_init)
}

